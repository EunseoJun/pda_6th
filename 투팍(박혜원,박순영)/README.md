# 📊 AWS EC2 인스턴스별 성능 비교

## ⭐ 목적

50명의 동시 사용자가 EC2 기반 웹 서비스에 접속하여 100, 1000, 5000번의 요청을 할 때의 서버 응답 시간, 처리량을 측정합니다.
여러 인스턴스 유형으로 테스트 한 후 **응답 시간**, **처리량**, **비용 대비 효율**에 따른 적절한 인스턴스 유형을 알아봅니다.

## 📌 개요
Flask 기반 API(`/api/calc`)의 연산 성능을 AWS EC2 인스턴스 유형별로 측정하고, **응답 시간**, **처리량**, **비용 대비 효율**을 종합적으로 비교했습니다.

- **실행 연산**: `sum([i**2 for i in range(1, 100000)])`  
- **성격**: 컴퓨팅 집약적 (CPU 성능 중심)

## 🖥️ 테스트 코드
from flask import Flask
app = Flask(__name__)
@app.route("/api/calc")
def calc():
    x = sum([i**2 for i in range(1, 100000)])  # CPU 부하
    return str(x)  #단순 문자열로 반환
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

## 🧪 테스트 환경

| 항목               | 내용                                       |
|--------------------|--------------------------------------------|
| 테스트 도구        | [`hey`](https://github.com/rakyll/hey)     |
| 요청 수 (`-n`)     | 100 / 1,000 / 5,000                         |
| 동시 접속자 수 (`-c`)| 50                                       |
| 실행 횟수          | 조건당 3회 평균                            |
| 응답 데이터        | 단순 문자열 (`str(x)`)                     |

## 💻 테스트 대상 인스턴스
(OS는 Linux/UNIX로 모든 인스턴스에서 동일하게 설정했습니다다)

| 인스턴스 유형 | vCPU | RAM  | 온디맨드 요금 ($/시간) |
|---------------|------|------|--------------------------|
| t2.nano        | 1    | 0.5GB | 0.0058                   |
| t2.xlarge      | 4    | 16GB  | 0.1856                   |
| t3.nano        | 2    | 0.5GB | 0.0052                   |
| t3.xlarge      | 4    | 16GB  | 0.1664                   |
| c5.large       | 2    | 4GB   | 0.0850                   |
| c5.xlarge      | 4    | 8GB   | 0.1700                   |
| m5.large       | 2    | 8GB   | 0.0960                   |
| m5.xlarge      | 4    | 16GB  | 0.1920                   |

---

## ⏱ 평균 응답 시간 (초)

![output (2)](https://github.com/user-attachments/assets/20dea761-111f-4e78-aa4e-26b1843cb9a2)

| 요청 수 | t2.nano | t2.xlarge | t3.nano | t3.xlarge | m5.large | m5.xlarge | c5.large | c5.xlarge |
|----------|---------|-----------|---------|-----------|----------|-----------|----------|-----------|
| 100      | 0.2885  | 0.2863    | 0.3420  | 0.3465    | 0.3233   | 0.3286    | 0.2726   | 0.2967    |
| 1000     | 0.3530  | 0.3648    | 0.4231  | 0.4390    | 0.3963   | 0.4105    | 0.3332   | 0.3365    |
| 5000     | 0.3602  | 0.3715    | 0.4540  | 0.4661    | 0.4092   | 0.4098    | 0.3363   | 0.3262    |

## ⚡ 초당 요청 처리량 (Requests/sec)

| 요청 수 | t2.nano | t2.xlarge | t3.nano | t3.xlarge | m5.large | m5.xlarge | c5.large | c5.xlarge |
|----------|---------|-----------|---------|-----------|----------|-----------|----------|-----------|
| 100      | 134.34  | 133.16    | 114.34  | 115.75    | 120.24   | 122.38    | 143.07   | 141.39    |
| 1000     | 138.32  | 133.78    | 115.43  | 111.25    | 123.32   | 121.97    | 146.97   | 145.86    |
| 5000     | 138.14  | 133.94    | 109.65  | 106.85    | 121.37   | 121.79    | 146.60   | 148.01    |

---

## 💵 가격 대비 성능 분석

![image](https://github.com/user-attachments/assets/e98c9e4e-edfd-4831-8c6b-eaefffb7744a)

| 인스턴스   | 요금 ($/h) | 평균 응답 (1000req) | 처리량 RPS | 요청/초 ÷ 비용 |
|------------|------------|----------------------|-------------|-----------------|
| t3.nano    | 0.0052     | 0.4231               | 115.43      | **22,198**      |
| t2.nano    | 0.0058     | 0.3530               | 138.32      | **23,849**      |
| c5.large   | 0.0850     | 0.3332               | 146.97      | **1,729**       |
| m5.large   | 0.0960     | 0.3963               | 123.32      | **1,284**       |
| c5.xlarge  | 0.1700     | 0.3365               | 145.86      | **858**         |
| m5.xlarge  | 0.1920     | 0.4105               | 121.97      | **635**         |

---

## 🔎 인스턴스별 특성 요약

### ✅ T 계열 (t2, t3)
- **버스트 성능 기반**: CPU 크레딧으로 제한적 고성능 발휘
- **지속 CPU 작업에는 부적합**
- **저렴한 비용, 제한적 성능**

### ✅ C 계열 (c5)
- **고성능 CPU 최적화**
- 컴퓨팅 집약적인 작업에 강력
- **가장 우수한 성능 대비 비용 효율**

### ✅ M 계열 (m5)
- 균형 잡힌 범용 인스턴스
- 실험 결과에서는 **비용 대비 성능이 C 계열보다 열세**

---


## ✅ 결론

- `c5.large`: 성능과 비용 측면에서 **최고의 가성비**
- `t2/t3.nano`: 비용만 저렴, **연산량 많을수록 비효율**
- `m5.xlarge`: `c5.xlarge`보다 비용은 더 높은데 해당 실험 환경에서는 성능은 낮았으므로 비추천

이번 실험은 단일 연산 집중형 API(/api/calc)를 기준으로 한 테스트로, CPU 계산 부하 중심의 작업에 특화되어 있습니다.
그 결과, **컴퓨팅 최적화 인스턴스인 C 계열 (특히 c5.large)**가 뛰어난 응답 시간과 처리량, 비용 대비 성능을 보였습니다.
반면 **M 계열 인스턴스 (예: m5.large, m5.xlarge)**는 CPU 성능보다는 균형 잡힌 범용 처리에 강점을 가지는 유형으로, 이번 실험에서는 그 장점을 충분히 발휘하지 못했습니다.

## 🔎 
따라서 단순히 M 계열을 '비효율적'이라고 결론짓기보다는 다음과 같은 관점이 필요합니다:
실제 서비스에서의 복합적인 I/O 작업, 예를 들어 데이터베이스 접근, 파일 처리, 네트워크 병렬 처리, 캐시 연동 등의 부하를 포함한다면 M 계열이 더 안정적일 수 있습니다.
메모리 의존도가 높은 애플리케이션에서는 C 계열보다 더 나은 퍼포먼스를 발휘할 수 있습니다.


---

## ✅ 아쉬운점

- 가용영역을 통일하지 못해서 이로인한 차이가 발생했을 수 있습니다.
- 성능 테스트에서는 단순히 동시 접속자 수(N)와 총 요청 수(R)만 정해놓는 것보다, **다양한 변수(접속자 수, 반복 횟수, 요청 간 간격, 부하 지속 시간)**를 함께 고려해 구성하는 것이 **보다 현실적이고 유의미한 결과**를 얻는 데 적합합니다.

---

## ✅ 추가 실험 제안
- I/O 중심 API 테스트: 파일 읽기/쓰기, 디스크 캐시 작업
- 네트워크 병렬 처리 부하 테스트: 여러 외부 API 호출 등
- 메모리 활용 테스트: 대량 JSON 파싱, pandas DataFrame 연산 등
- 실제 웹 애플리케이션 부하 시나리오 구성: DB 연동 + 비동기 요청 처리
